---
title: 快速幂与矩阵快速幂
date: 2021-8-10
mathjax: true
tags:
    算法
    acm
---

# 快速幂与矩阵快速幂

#### 作者：碳碳双键

#### 创建于：2021-08-10


# **引例**

首先我们来看一个ACM程序设计的题目：[HDU-2035](https://acm.hdu.edu.cn/showproblem.php?pid=2035)
![题目描述](/uploads/Article_Picture/HDU-2035.png)


<!-- more -->


如果我们要计算𝑎^𝑏 mod p,我们首先能想到的便是for循环

```c++
int ans = 1;
for(int i = 1; i <= b; i++) { 
    ans *= a; 
}
return ans % p;
```
下面我们来看看两个例子，想一想会出现什么结果？
>Q1： 2^100 mod 1000 
>Q2： 5^2𝑒12  mod 1000

第二个结果我们能一眼看出来，就是循环次数过多。所以说解决这个问题O(n)是不行的。
那第一个奇葩结果就是 2^100 已经溢出了。


> ​    因此，如果题目让你求2的100次方，貌似我们程序设计语言中最大的long lnog类型也无法承载这么大的数值，所以题目才不会要求你输出结果，因为结果可能会非常的大，大到没有任何类型可以承载。所以我们会发现上面的结果为什么是0，因为已经发生溢出了。


---


# **在引入本章算法之前，来看一个经典的例子“指数爆炸”** 



> ​    一张纸对折一次，厚度变成原来的2倍。再对折第二次，变为原来的2的2次方倍即4倍。以此类推，假设纸的厚度为0.1mm，则对折24次以后，长度超过1千米；对折39次达55000千米，超过地球赤道长度；对折42次达44万千米，超过地球至月球的距离；对折51次达22亿千米，超过地球至太阳的距离；对折82次为51113光年，超过银河系半径的长度。



在这个题目中，我们在计算2^100次方时，数据就已经超出long long的范围了，造成数据溢出，导致最终计算出的结果也是错误的。

> ​    那为什么题目要求输出结果的最后三位数表示的整数呢？有的同学可能会问：求一个数的最后三位数表示的整数好办，只要用这个结果进行“取模”运算，让其对1000取模，得到的数就是这个数最后三位数表示的整数。（例如：12345的最后三位数表示的整数是：12345%1000=345）。但是，你这结果都无法求出来，让我怎么进行“取模”运算呢？你这不是瞎闹吗？



# **快速幂**


## **1. 解决溢出问题**

取模运算公式：
$$
(a + b) \% p = [(a \% p) + (b \% p)] \% p\\
(a - b) \% p = [(a \% p) - (b \% p)] \% p\\
(a * b) \% p = [(a \% p) * (b \% p)] \% p\\
$$
这里我们主要用到第三个公式：$(a * b) \% p = [(a \% p) * (b \% p)] \% p$

进一步拓展，我们可以发现，多因子连乘后取模的结果等于每个因子取模后的乘积再取模的结果。

即：$(a * b * c) \% p = [(a \% p) * (b \% p) * (c \%p)] \% p$



因此运用在前面的代码，可以转化成边乘边取模，代码可以优化成：

```c++
int ans=1;
for(int i = 1; i <= b; i++) { 
    ans *= a % p; 
}
return ans%p;
```
通过计算我们可以发现，时间复杂度为$O(N)$​，假设要我们求的是2的1e 9次方呢？显然我们这个算法的复杂度还是过高。

## **2. 优化时间复杂度**

使用快速幂算法，可以将时间复杂度优化到$O(logN)$​，这个算法可以基于递归实现，也可以通过迭代实现。

核心思想：每一步都将指数分成两半，而相应的底数做平方运算。这样不仅把指数降低了，同时循环次数降低了。

例如：

> 3^10 = 3\*3\*3\*3\*3\*3\*3\*3\*3\*3
>
> ​			= (3\*3)\*(3\*3)\*(3\*3)\*(3\*3)\*(3\*3)
>
> ​			= (3\*3)^5
>
> ​			= 9^5
>
> ​			= (9\*9)*(9\*9)\*9
>
> ​			= 9\*(81^2)
>
> ​			= 59049



## **算法步骤：**

如果指数为偶数，则指数除2， 底数平方，同时取模

如果指数为奇数，则指数除2，底数平方，同时连乘器上再乘上一个底数。

注意边乘边取模



### **快速幂模板代码**

#### ==**初级版**==

```c++
long long fastPower(long long base, long long power) {
    long long result = 1;
    while (power > 0) {
        if (power % 2 == 0) {
            //如果指数为偶数
            power = power / 2;//把指数缩小为一半
            base = base * base % 1000;//底数变大成原来的平方
        } else {
            //如果指数为奇数
            power = power - 1;//把指数减去1，使其变成一个偶数
            result = result * base % 1000;//此时记得要把指数为奇数时分离出来的底数的一次方收集好
            power = power / 2;//此时指数为偶数，可以继续执行操作
            base = base * base % 1000;
        }
    }
    return result;
}
```

#### ==**优化版**==

```c++
long long fastPower(long long base, long long power) {
    long long result = 1;
    while (power > 0) {
        if (power % 2 == 1) {
            result = result * base % 1000;
        }
        power = power / 2;
        base = (base * base) % 1000;
    }
    return result;
}
```

#### ==**终极优化版**==

```c++
long long fastPower(long long base, long long power) {
    long long result = 1;
    while (power > 0) {
        if (power & 1) {//此处等价于if(power%2==1)
            result = result * base % 1000;
        }
        power >>= 1;//此处等价于power=power/2
        base = (base * base) % 1000;
    }
    return result;
}
```

----

# **龟速乘**

## **龟速乘的诞生--快速幂的BUG**

> 假设给你一个$a^{b}$​ mod p的式子
>
> 现在的你已经可以说：我能够在$O(logb)$​的时间里算出来了吗？（和善的眼神x2）
>
> 你确定？（和善的眼神x3）

下面这组数据来看看你的快速幂是否还活着：

> 19260817 2333333 1234567654321

很显然，即使我们按照取模公式，在乘的过程中对p取余，依然避免不了在乘法过程中爆掉long long的情况。

很好，现在我们找到了快速幂算法的一个问题：当模数>1e9的时候，在相乘的时候爆long long了。（当然你可以手写高精只要你高兴 ）

那怎么办？这种情况下我们就不能用快速幂了吗？

当然是可以的，但是我们需要为快速幂这一BUG打上补丁。

这里也就引出了我们的新算法--龟速乘

其核心思路和快速幂是一样的，理解了快速幂，自然就可以理解龟速乘。

## **模板代码**

```c++
ll fast_mult(ll a, ll b) {
    ll res = 0;
    while (b > 0) {
        if (b & 1) {
            res = (res + a) % p;
        }
        b >>= 1;
        a = (a + a) % p;
    }
    return res % p;
}
```



# **矩阵快速幂**



何为矩阵快速幂，其实是我们前面用到快速幂，将底数a换为矩阵，计算矩阵a的b次幂即可。

首先我们来回顾一下矩阵乘法的知识。

根据线性代数的知识我们也容易知道，两个矩阵相乘，前提是A的列数与B的行数相等，结果是其在新矩阵的行所对应的A的行与在新矩阵的列所对应的B的列对应相乘相加。

![矩阵乘法例图](/uploads/Article_Picture/矩阵乘法例图.png)


$$
C_0 = A_0*B_0+A_1*B_2\\
C_1 = A_0*B_1+A_1*B_3\\
C_2 = A_2*B_0+A_3*B_2\\
C_3 = A_2*B_1+A_3*B_3
$$
所以我们可以先得出矩阵乘法的代码：

```c++
for(int i = 1; i <= n; i++)
      for(int j = 1; j <= n; j++)
           for(int k = 1; k <= n; k++)
	     				c[i][j] = (c[i][j]+a[i][k] * b[k][j]) % mod;
```

补充小tips：

> 矩阵的0次方等于单位矩阵。
>
> 矩阵乘法满足：结合律和分配率，不满足交换律。





在了解了什么是矩阵以及矩阵的乘法之后我们来看下面这个熟悉的问题: Fibonacci.



<img src="/Users/yinsm/文档图片/斐波拉契例题.png" alt="斐波拉契例题" style="zoom:50%;" />

不过此时的n已经到达10^18,自然不可能再用我们之前那种O(n)的递推,那我们能怎么办呢?

---

## **矩阵快速幂的构造**



首先我们研究一下Fibonacci数列的递推公式：
$$
f[0] = 0，f[1] = 1\\
f[n] = f[n-1]+f[n-2] (n >= 2)
$$

设$C_n$代表一个矩阵，构造出一个B矩阵：

$C_n = \begin{bmatrix} 
  f[n]\\
f[n-1]
\end{bmatrix}$               $B = \begin{bmatrix} 
  1 & 1\\
  1 & 0
\end{bmatrix}$​

则我们将原本的递推公式构造成矩阵乘法的形式后可以得到：
$$
C_n = \begin{bmatrix}  
  f[n]\\  
  f[n-1]\\   
\end{bmatrix} = \begin{bmatrix} 
1 & 1\\
1 & 0\\  
\end{bmatrix} *
\begin{bmatrix} 
  f[n-1]\\
  f[n-2]
\end{bmatrix}
$$
进一步，$C_n = B * C(n-1)$​​​​可以推出：

$C_n = \begin{bmatrix}  
  f[n]\\  
  f[n-1]\\   
\end{bmatrix} = \begin{bmatrix} 
1 & 1\\
1 & 0\\  
\end{bmatrix}^{n-1} *
\begin{bmatrix} 
  f[1]\\
  f[0]
\end{bmatrix}$​​​

那么对于这个问题，我们只需要用快速幂求出$B^{n-1}$​的结果，最后再做一次矩阵乘法，矩阵C的**第一个值**就是最后的答案$f[n]$。



上面的过程相信大家都能看明白，但是B矩阵是怎么构造出来的呢？



### **一个简单的问题。**

> 如果对于任意一个形如$f[n] = a*f[n-1] + b*f[n-2]$的表达式，我们需要怎么构造B矩阵呢？
>

对于上面的表达式，我们进行如下思考：

设矩阵$C_n = \begin{bmatrix} 
  f[n]\\
f[n-1]
\end{bmatrix}$​​​​​，则$C_{n-1} = \begin{bmatrix} 
  f[n-1]\\
f[n-2]
\end{bmatrix}$​​​​

矩阵乘法可以表示为：$C_n = B * C_{n-1}=B^{n-1}*C_1$

因此：$C_n = \begin{bmatrix}  
  f[n]\\  
  f[n-1]\\   
\end{bmatrix} = \begin{bmatrix} 
a & b\\
1 & 0\\  
\end{bmatrix}^{n-1} *
\begin{bmatrix} 
  f[1]\\
  f[0]
\end{bmatrix}$​



### **一个更难的问题。**

> 请求出下面表达式的B矩阵
>
> $f[n] = 3*f[n-1] + 5*f[n-3] + 9f[n-4]$​​
>
> 首先，表达式中缺少$f[n-2]$​的项，我们在构造的时候需要注意。
>

---

$C_n = \begin{bmatrix} 
  f[n]\\
f[n-1]\\
f[n-2]\\
f[n-3]
\end{bmatrix} = \begin{bmatrix} 
  3 & 0 & 5 & 9\\
  1 & 0 & 0 & 0\\
  0 & 1 & 0 & 0\\
  0 & 0 & 1 & 0
\end{bmatrix} * \begin{bmatrix} 
  f[n-1]\\
f[n-2]\\
f[n-3]\\
f[n-4]
\end{bmatrix}$​​



### **一个更更难的问题。**

> 构造出下面表达式的B矩阵
>
> $f[n] = a*f[n-1] + b*f[n-3] + c$
>

---

相比于前面的递推式，现在这个多了一个常数项

因此，构造出的B矩阵如下：

$C_n = \begin{bmatrix} 
  f[n]\\
f[n-1]\\
f[n-2]\\
c
\end{bmatrix} = \begin{bmatrix} 
  a & 0 & b & 1\\
  1 & 0 & 0 & 0\\
  0 & 1 & 0 & 0\\
  0 & 0 & 0 & 1
\end{bmatrix} * \begin{bmatrix} 
  f[n-1]\\
f[n-2]\\
f[n-3]\\
c
\end{bmatrix}$



### **一个更更更难的问题。**

> 已知：$f[1] = 1, f[2] = 2, f[n] = f[n-1] + 2*f[n-2] + n^{3}$
>
> 构造出上述表达式的B矩阵？
>

---


难点：相比于前面的表达式，这个表达式多出了一个变量$n^{3}$​，在构造的时候，我们需要考虑如何把$n^{3}$构造成一个由$(n-1)$​​组成的式子。

要点：对于这个问题，我们可以采用**二项式定理**(这个定理在学习母函数的时候也会用到)。



![二项式定理例图](/uploads/Article_Picture/二项式定理例图.png)

这样，我们可以得到下面的表达式：
$$
n^{3} = (n-1+1)^{3}= 
C_3^{0}(n-1)^{3}(1)^{0} + C_3^{1}(n-1)^{2}(1)^{1} + C_3^{2}(n-1)^{1}(1)^{2} + C_3^{3}(n-1)^{0}(1)^{3}\\= (n-1)^{3} + 3(n-1)^{2} + 3(n-1) + 1
$$
$f[n] = f[n-1] + 2*f[n-2] + n^{3} = f[n-1] + 2*f[n-2] + (n-1)^{3} + 3(n-1)^{2} + 3(n-1) + 1$

对于此时对上式构造B矩阵即可：

$C_n = \begin{bmatrix} 
  f[n]\\
f[n-1]\\
n^{3}\\
n^{2}\\
n\\
1
\end{bmatrix} = \begin{bmatrix} 
  1 & 2 & 1 & 3 & 3 & 1\\
  1 & 0 & 0 & 0 & 0 & 0\\
  0 & 0 & 1 & 3 & 3 & 1\\
  0 & 0 & 0 & 1 & 2 & 1\\
  0 & 0 & 0 & 0 & 1 & 1\\
  0 & 0 & 0 & 0 & 0 & 1
\end{bmatrix} * \begin{bmatrix} 
  f[n-1]\\
f[n-2]\\
(n-1)^{3}\\
(n-1)^{2}\\
n-1\\
1
\end{bmatrix} = \begin{bmatrix} 
  1 & 2 & 1 & 3 & 3 & 1\\
  1 & 0 & 0 & 0 & 0 & 0\\
  0 & 0 & 1 & 3 & 3 & 1\\
  0 & 0 & 0 & 1 & 2 & 1\\
  0 & 0 & 0 & 0 & 1 & 1\\
  0 & 0 & 0 & 0 & 0 & 1
\end{bmatrix}^{n-2} * \begin{bmatrix} 
  f[2]\\
f[1]\\
(2)^{3}\\
(2)^{2}\\
2\\
1
\end{bmatrix}$​​​​​

其中B矩阵为：

$B = \begin{bmatrix} 
  1 & 2 & 1 & 3 & 3 & 1\\
  1 & 0 & 0 & 0 & 0 & 0\\
  0 & 0 & 1 & 3 & 3 & 1\\
  0 & 0 & 0 & 1 & 2 & 1\\
  0 & 0 & 0 & 0 & 1 & 1\\
  0 & 0 & 0 & 0 & 0 & 1
\end{bmatrix}$​​



### **一个更更更更难的问题**

> 带前缀和的矩阵快速幂:
>
> 已知：$T[0] = T[1] = T[2] = 1, T[n] = T[n-1] + T[n-2] + T[n-3] (n >= 3)$
>
> 求：$(T[a] + T[a+1] + ... + T[b]) \% (1e9 + 7) . (1 <= a <= b <= 1e9)$​ 
>



先求前缀和，$S_{ans} = S[b] - S[a-1]$，$\because S[n] = S[n-1] + T[n]$ ,

 $\therefore  S[n] = S[n-1] + T[n-1] + T[n-2] + T[n-3]$

因此原问题转化成：对上式求B矩阵，得到目标区间a～b的区间和。

$S_{n} = S_{n-1} + T[n] + T[n-1] + T[n-2] $

构造出一下矩阵：

$$
C_n = \begin{bmatrix} 
  S[n]\\
T[n]\\
T[n-1]\\
T[n-2]\\
\end{bmatrix} = \begin{bmatrix} 
  1 & 1 & 1 & 1 \\
  0 & 1 & 1 & 1\\
  0 & 1 & 0 & 0\\
  0 & 0 & 1 & 0\\
\end{bmatrix} * \begin{bmatrix} 
  S[n-1]\\
T[n-1]\\
T[n-2]\\
T[n-3]\\
\end{bmatrix} = \begin{bmatrix} 
  1 & 1 & 1 & 1 \\
  0 & 1 & 1 & 1\\
  0 & 1 & 0 & 0\\
  0 & 0 & 1 & 0\\
\end{bmatrix} ^{n-2} * \begin{bmatrix} 
  S[2]\\
T[2]\\
T[1]\\
T[0]\\
\end{bmatrix}
$$


### **一个更更更更更难的问题。**

> 已知：$A[0] = 1, A[1] = 1, A[n] = X*A[n-1] + Y*A[n-2] ,(n >= 2)$​​
>
> 求$S[n] = \sum A(i)^{2}, (0 <= i <= n)$​ ？
>


---


表达式整理：

$\because S[n] = S[n-1] + A[n]^{2}$

$\because A[n]^{2} = X^{2} * A[n-1]^{2} + 2*X*Y*A[n-1]A[n-2] + Y^{2}*A[n-2]^{2}$

$\therefore S[n] = S[n-1] + X^{2} * A[n-1]^{2} + 2*X*Y*A[n-1]A[n-2] + Y^{2}*A[n-2]^{2}$

$\therefore A[n]A[n-1] = X*A[n-1]^{2} + Y*A[n-1]A[n-2]$​

矩阵向量列至少应该包含：$S[n]$​, $A[n]^{2}$​, $A[n]A[n-1]$​, $A[n-1]^{2}$​四项。

因此构造出下面的矩阵表达式：

$C_n = \begin{bmatrix} 
  S[n]\\
A[n]^{2}\\
A[n]A[n-1]\\
A[n-1]^{2}
\end{bmatrix} = \begin{bmatrix} 
  1 & X^{2} & 2XY & Y^{2}\\
  0 & X^{2} & 2XY & Y^{2}\\
  0 & X & Y & 0\\
  0 & 1 & 0 & 0
\end{bmatrix} * \begin{bmatrix} 
  S[n-1]\\
A[n-1]^{2}\\
A[n-1]A[n-2]\\
A[n-2]^{2}
\end{bmatrix} = \begin{bmatrix} 
  1 & X^{2} & 2XY & Y^{2}\\
  0 & X^{2} & 2XY & Y^{2}\\
  0 & X & Y & 0\\
  0 & 1 & 0 & 0
\end{bmatrix} ^ {n-1} * \begin{bmatrix} 
  S[1]\\
A[1]\\
A[1]A[0]\\
A[0]^{2}
\end{bmatrix}$​

本题特点：不仅需要前缀和，还递推公式比较复杂（含乘法项）



### **最后一个问题。**

> 对于一个01循环串，长度为L, $(L<=100)$，这个串每秒都会进行一次变换，变换的条件是：如果左边的字符是1，则改变当前位的状态，否则不改变。给定初始状态，问n秒后，这个串的状态。
>


---

问题分析：定义状态 $f[n, L]$表示n秒后，第L个字符是0还是1。得到如下转移方程：

$f[n,L] = \left\{\begin{matrix} 
  f[n-1, L] ,f[n-1, L-1] = 0\\  
  1-f[n-1,L] ,f[n-1, L-1] = 1\\
\end{matrix}\right. $​​​




变式可得：

$f[n,L] = \left\{\begin{matrix} 
  f[n-1, L-1] + f[n-1, L]\\  
  f[n-1, L-1]-f[n-1,L]\\\end{matrix}\right. $​​

由同余的性质可推出：$f[n,L] = f[n-1, L-1] + f[n-1, L]$

> 解释：
>
> 如果前一个数是1的话，当前这位如果是1，就要变成0，相当于(1+1)%2=0 如果是0变成1就相当于(1+0)%2=1 如果是0的话保持不变 （当前这位+0）% 2还是等于当前这位
>
> 所以就是f(n,L)=f(n-1,L)+f(n-1,L-1)



对上面的表达式构造B矩阵（注意：需要构造二维的B矩阵）：
$$
\begin{bmatrix} 
  f[n,1]\\
f[n, 2]\\
...\\
f[n, L]
\end{bmatrix} = \begin{bmatrix} 
1 & 0 & ... & 0 & 1\\
1 & 1 & ... & 0 & 0\\
... & ... & ... & 1 & 0\\
0 & 0 & ... & 1 & 1
\end{bmatrix} * \begin{bmatrix} 
f[n-1, 1]\\
f[n-1, 2]\\
...\\
f[n-1, L]  
\end{bmatrix} = \begin{bmatrix} 
1 & 0 & ... & 0 & 1\\
1 & 1 & ... & 0 & 0\\
... & ... & ... & 1 & 0\\
0 & 0 & ... & 1 & 1
\end{bmatrix} ^{n} * \begin{bmatrix} 
f[0, 1]\\
f[0, 2]\\
...\\
f[0, L]  
\end{bmatrix}
$$

# 矩阵快速幂应用场景

已经有递推式,求$f[n]$，但是$n$​很大。

# 矩阵快速幂的关键

* 求解递推式

* 构造B矩阵。

# 矩阵快速幂模板

### ==**构造矩阵**==

```c++
struct mat
{
    ll m[maxn][maxn];
    mat(ll e = 0){
        for(int i = 0; i < n; i++){
            for(int j = 0; j < n; j++){
                m[i][j] = e*(i == j);
            }
        }
    }
}unit;
```

### ==**重载*号**==

```c++
mat mult(mat a, mat b){   //重载*号
    mat ret(0);
    for(int i = 0; i < n; i++){
        for(int j = 0; j < n; j++){
            for(int k = 0; k < n; k++){
                ret.m[i][j] = (ret.m[i][j] + a.m[i][k] * b.m[k][j]) % mod;
            }
        }
    }
    return ret;
}
```

### ==**初始化单位矩阵**==

```c++
void init_unit(){   //初始化单位阵
    for(int i = 0; i < n; i++){
        unit.m[i][i] = 1;    //主对角线上的元素为1
    }
}
```

### ==**矩阵快速幂**==

```c++
mat ksm(mat a, int k){
    init_unit();
    mat ret = unit;
    while(k){
        if(k & 1) ret = mult(ret, a);
        a = mult(a, a);
        k >>= 1;
    }
    return ret;
}
```

